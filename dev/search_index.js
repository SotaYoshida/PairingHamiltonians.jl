var documenterSearchIndex = {"docs":
[{"location":"bcs/#BCS","page":"BCS","title":"BCS","text":"","category":"section"},{"location":"bcs/","page":"BCS","title":"BCS","text":"Modules = [PairingHamiltonian]\nPages = [\"bcs.jl\"]","category":"page"},{"location":"bcs/#PairingHamiltonian.BCS-NTuple{6, Any}","page":"BCS","title":"PairingHamiltonian.BCS","text":"BCS(Norb, Nocc, epsilon, gval, to, debug_mode; max_iter=1000)\n\nMain function to calculate the ground state energy of the BCS Hamiltonian.\n\nArguments\n\nNorb::Int: number of orbitals\nNocc::Int: number of occupied states\nepsilon::Vector{Float64}: single-particle energies\ngval::Float64: interaction strength\nto::TimerOutput: timer object to measure the elapsed time\ndebug_mode::Int: specifying the debug mode\n\nOptional arguments\n\nmax_iter::Int(1000): maximum number of iterations\n\n\n\n\n\n","category":"method"},{"location":"bcs/#PairingHamiltonian.E_BCS_from_uv-NTuple{7, Any}","page":"BCS","title":"PairingHamiltonian.E_BCS_from_uv","text":"E_BCS_from_uv(epsilon, epsilon_p, vs, Delta, lambda, gval, debug_mode)\n\nCalculate the ground state energy of the BCS Hamiltonian from the Bogoliubov coefficients vs and us:\n\nE_mathrmBCS = sum_a left( epsilon_a  v^2_a - fracg v^4_a2 right)\n\n\n\n\n\n","category":"method"},{"location":"bcs/#PairingHamiltonian.Neval-Tuple{Any, Any, Any}","page":"BCS","title":"PairingHamiltonian.Neval","text":"Neval(epsilon_p, lambda, Delta)::Float64\n\nCalculate the expectation value of the particle number from the chemical potential lambda and the gap parameter Delta via the following equation:\n\nN  = sum_alpha frac12 left( 1 - fracepsilon_a - lambdasqrt(epsilon_a - lambda)^2 + Delta^2 right)\n\n\n\n\n\n","category":"method"},{"location":"bcs/#PairingHamiltonian.eval_Delta-Tuple{Any, Any, Any}","page":"BCS","title":"PairingHamiltonian.eval_Delta","text":"eval_Delta(vs, us, gval)\n\nCalculate the gap parameter Delta: Delta equiv fracg2 sum_alpha u_a v_a\n\nArguments\n\nvs::Vector{Float64}: v[i]\nus::Vector{Float64}: u[i]\ngval::Float64: g\n\n\n\n\n\n","category":"method"},{"location":"bcs/#PairingHamiltonian.eval_eps_p!-NTuple{4, Any}","page":"BCS","title":"PairingHamiltonian.eval_eps_p!","text":"eval_eps_p!(epsilon_p, epsilon, vs, gval)\n\nCalculate the epsilon_p from epsilon and vs.\n\nArguments\n\nepsilon_p::Vector{Float64}: epsilon_p[i] = epsilon[i] - g v[i]^2\nepsilon::Vector{Float64}: epsilon[i]\nvs::Vector{Float64}: v[i]\n\n\n\n\n\n","category":"method"},{"location":"bcs/#PairingHamiltonian.reeval_Delta","page":"BCS","title":"PairingHamiltonian.reeval_Delta","text":"reeval_Delta(lambda, Delta, epsilon_p, gval, debug_mode, alpha=0.5)::Float64\n\nUpdate the gap parameter Delta iteratively with the following equation:\n\nDelta^mathrmnew = alpha Delta^mathrmnew + (1-alpha) fracg4 sum_alpha fracDeltasqrt(epsilon_a - lambda)^2 + Delta^2\n\nArguments\n\nlambda::Float64: chemical potential\nDelta::Float64: current gap parameter\nepsilon_p::Vector{Float64}: epsilon_p[i] = epsilon[i] - g v[i]^2\ngval::Float64: g\ndebug_mode::Int: specify the debug mode\nalpha::Float64: mixing parameter to update Delta, which may be useful to stabilize the calculation\n\n\n\n\n\n","category":"function"},{"location":"bcs/#PairingHamiltonian.update_lambda","page":"BCS","title":"PairingHamiltonian.update_lambda","text":"update_lambda(Nocc, lambda, Delta, epsilon_p, gval, debug_mode, alpha=0.5)\n\nUpdate the chemical potential lambda iteratively with the following equation:\n\nlambda^mathrmnew = fracg2 left( N_mathrmocc - fracN_mathrmorb2 + frac12 sum_alpha fracepsilon_a sqrt(epsilon_a - lambda)^2 + Delta^2 right)\n\nArguments\n\nNocc::Int: number of occupied states\nlambda::Float64: chemical potential\nDelta::Float64: gap parameter\nepsilon_p::Vector{Float64}: epsilon_p[i] = epsilon[i] - g v[i]^2\ngval::Float64: g\ndebug_mode::Int: specify the debug mode\nalpha::Float64: mixing parameter to update lambda\n\n\n\n\n\n","category":"function"},{"location":"bcs/#PairingHamiltonian.uv_from_Lam_Delta!-Tuple{Any, Any, Vector{Float64}, Vector{Float64}, Vector{Float64}}","page":"BCS","title":"PairingHamiltonian.uv_from_Lam_Delta!","text":"uv_from_Lam_Delta!(Delta, lambda, epsilon_p::Vector{Float64}, us::Vector{Float64}, vs::Vector{Float64})\n\nDestructively update the Bogoliubov coefficients us and vs from the gap parameter Delta and the chemical potential lambda:\n\nu^2_a = frac12 left( 1 + fracepsilon_a - lambdasqrt(epsilon_a - lambda)^2 + Delta^2 right)  \nv^2_a = frac12 left( 1 - fracepsilon_a - lambdasqrt(epsilon_a - lambda)^2 + Delta^2 right) \n\nArguments\n\nDelta::Float64: gap parameter\nlambda::Float64: chemical potential\nepsilon_p::Vector{Float64}: epsilon_p[i] = epsilon[i] - g v[i]^2\nus::Vector{Float64}: u coefficients of Bogoliubov transformation\nvs::Vector{Float64}: v coefficients of Bogoliubov transformation\n\n\n\n\n\n","category":"method"},{"location":"imsrg/#In-Medium-Similarity-Renormalization-Group-(IMSRG)","page":"IM-SRG","title":"In-Medium Similarity Renormalization Group (IMSRG)","text":"","category":"section"},{"location":"imsrg/","page":"IM-SRG","title":"IM-SRG","text":"Functions for the In-Medium Similarity Renormalization Group (IMSRG) method.","category":"page"},{"location":"imsrg/","page":"IM-SRG","title":"IM-SRG","text":"Under the current implementation, the IMSRG is the most time-consuming method among the ones available in the package. One should consider to run a script using multiple threads to speed up the calculations like the following example:","category":"page"},{"location":"imsrg/","page":"IM-SRG","title":"IM-SRG","text":"julia -t 12 path_to_script.jl","category":"page"},{"location":"imsrg/","page":"IM-SRG","title":"IM-SRG","text":"Some functions in the package are already parallelized, but it may be still insufficient for large systems.","category":"page"},{"location":"imsrg/","page":"IM-SRG","title":"IM-SRG","text":"Modules = [PairingHamiltonian]\nPages = [\"imsrg.jl\"]","category":"page"},{"location":"imsrg/#PairingHamiltonian.IMSRG-NTuple{7, Any}","page":"IM-SRG","title":"PairingHamiltonian.IMSRG","text":"IMSRG(HNO, holes, particles, gval, Nocc, to, debug_mode; smax = 15.0, tol_eta=1.e-4, ds=1.e-2)\n\nMain function to perform the IMSRG calculation.\n\nArguments\n\nHNO::Hamiltonian_NormalOrdered: Hamiltonian in normal ordered form\nholes::Vector{Int64}: indices of the holes\nparticles::Vector{Int64}: indices of the particles\ngval::Float64: strength of the interaction\nNocc::Int64: number of occupied orbitals\nto::TimeOutput: output object to measure the time\ndebug_mode::Int64: level of debug information\n\nOptional arguments\n\nsmax::Float64: maximum value of the flow parameter\ntol_eta::Float64: tolerance of the generator\nds::Float64: step size of the flow parameter\n\nReferences\n\nHeiko Hergert, Scott K. Bogner, Justin G. Lietz, Titus D. Morris, Samuel J. Novario, Nathan M. Parzuchowski & Fei Yuan: In-Medium Similarity Renormalization Group Approach to the Nuclear Many-Body Problem, part of the book series: Lecture Notes in Physics ((LNP,volume 936))\n\n\n\n\n\n","category":"method"},{"location":"imsrg/#PairingHamiltonian.eta_white_atan!-NTuple{8, Any}","page":"IM-SRG","title":"PairingHamiltonian.eta_white_atan!","text":"eta_white_atan!(eta_1b, eta_2b, f, Γ, idx2b, kets, holes, particles)\n\nDestructive function to evaluate the generator of IMSRG flow equation, η.\n\nbeginalign\neta  = eta^(1) + eta^(2) nonumber \n = frac12 sum_ph arctanleft(fracf_ph(s)Delta_ph(s)right)   a^dagger_p a_h \n+ frac18 sum_pphh arctanleft(frac2 Gamma_pphh(s)Delta_pphh(s)right)   a^dagger_p a^dagger_p a_h a_h  - Hc nonumber\nendalign\n\n\n\n\n\n","category":"method"},{"location":"imsrg/#PairingHamiltonian.eval_2b_ph_trans!-NTuple{6, Any}","page":"IM-SRG","title":"PairingHamiltonian.eval_2b_ph_trans!","text":"eval_2b_ph_trans!(eta, eta_ph, Γ, Γ_ph, idx2b, kets)\n\nEvaluating A_ibarjkbarl = - A_ijkl destructively. Those will be used for making the 2-body part of the flow equation faster. \n\n\n\n\n\n","category":"method"},{"location":"imsrg/#PairingHamiltonian.eval_derivatives!-Tuple{PairingHamiltonian.Operator, Vararg{Any, 14}}","page":"IM-SRG","title":"PairingHamiltonian.eval_derivatives!","text":"eval_derivatives!(dH, eta_1b, eta_2b, f, Γ, idx2b, coppy_matrices, kets, kets_ph,                     \n                       holes, particles, holes_2b, particles_2b, to, debug_mode)\n\nTo evaluate the derivatives of the Hamiltonian operator, we need to evaluate the following terms:\n\nbeginalign\nfracdEds = sum_ab (n_a-n_b) eta^(1)_ab f_ba \n+ frac12 sum_abcd eta^(2)_abcd Gamma_cdab n_an_b barn_c barn_d nonumber \nfracdf_pqds = sum_a (1+P_pq) eta^(1)_pa f_aq \n+ sum_ab (n_a-n_b) (eta^(1)_ab Gamma_bpaq - f_ab eta^(2)_bpaq)  nonumber \n + frac12 sum_abc (n_an_bbarn_c + barn_a barn_b n_c) (1+P_pq) eta^(2)_cpab Gamma_abcq nonumber \nfracdGamma_pqrsds = sum_a \nleft (1-P_pq) (eta^(1)_pa Gamma_aqrs - f_pa eta^(2)_aqrs) -(1-P_rs) (eta^(1)_ar Gamma_pqas - f_ar eta^(2)_pqas) right nonumber  \n + frac12 sum_ab (1-n_a-n_b) (eta^(2)_pqab Gamma_abrs - Gamma_pqab eta^(2)_abrs)nonumber  \n - sum_ab (n_a - n_b) (1-P_pq)(1-P_rs) eta^(2)_bqas Gamma_apbr nonumber \nendalign\n\nwhere P_pq is the permutation operator, and n_a is the occupation number of the orbital a.\n\n\n\n\n\n","category":"method"},{"location":"coupledcluster/#Coupled-Cluster","page":"Coupled Cluster","title":"Coupled Cluster","text":"","category":"section"},{"location":"coupledcluster/","page":"Coupled Cluster","title":"Coupled Cluster","text":"Modules = [PairingHamiltonian]\nPages = [\"coupled_cluster.jl\"]","category":"page"},{"location":"coupledcluster/#PairingHamiltonian.CCD-NTuple{5, Any}","page":"Coupled Cluster","title":"PairingHamiltonian.CCD","text":"CCD(F, gval, Nocc, to, debug_mode; itnum=100, tol=1e-9, mix_ratio=0.25)\n\nMain function to calculate the ground state energy of the pairing Hamiltonian using the coupled cluster method. Since the Hamiltonian is the pairing model, we don't need to consider 1p1h excitations, CCD instead of CCSD, etc.\n\nArguments\n\nF::Array{Float64, 2}: Fock matrix from the Hartree-Fock calculation\ngval::Float64: strength of the pairing interaction\nNocc::Int: number of occupied states\nto::TimerOutput: timer object to measure the elapsed time\ndebug_mode::Int: specifying the debug mode\n\nOptional arguments\n\nitnum::Int(100): maximum number of iterations\ntol::Float64(1e-9): convergence criterion\nmix_ratio::Float64(0.25): mixing ratio for the update of the t2 amplitudes\n\nReferences\n\nShavitt, I., & Bartlett, R. J. (2009). Many-body methods in chemistry and physics: MBPT and coupled-cluster theory. Cambridge University Press.\nJustin G. Lietz, Samuel Novario, Gustav R. Jansen, Gaute Hagen & Morten Hjorth-Jensen, Computational Nuclear Physics and Post Hartree-Fock Methods, part of the book series: Lecture Notes in Physics ((LNP,volume 936))\n\n\n\n\n\n","category":"method"},{"location":"coupledcluster/#PairingHamiltonian.construct_chi","page":"Coupled Cluster","title":"PairingHamiltonian.construct_chi","text":"i,j,k are hole indices, a,b,c are particle indices.\n\n\n\n\n\n","category":"function"},{"location":"coupledcluster/#PairingHamiltonian.eval_χ_hhhh!-NTuple{5, Any}","page":"Coupled Cluster","title":"PairingHamiltonian.eval_χ_hhhh!","text":"langle kl  chi  ij rangle  = langle kl  v  ij rangle + frac12 sum_cd langle kl  v  cd rangle langle cd  t  ij rangle\n\n\n\n\n\n","category":"method"},{"location":"coupledcluster/#PairingHamiltonian.get_vecidx-Tuple{Any, Any, Any}","page":"Coupled Cluster","title":"PairingHamiltonian.get_vecidx","text":"To get continuous idx for pp or hh from i and j.\n\n\n\n\n\n","category":"method"},{"location":"coupledcluster/#PairingHamiltonian.hash_key4-NTuple{4, Any}","page":"Coupled Cluster","title":"PairingHamiltonian.hash_key4","text":"hash_key4(i, j, a, b)::UInt64\n\nFunction to encode i,j,a,b into a single UInt64. From the lowest 8 bits, b, a, j, i are stored. If you want to work with larger model space, requiring e.g. single particle states > 255, you need to modify this function.\n\n\n\n\n\n","category":"method"},{"location":"coupledcluster/#PairingHamiltonian.unhash_key4-Tuple{UInt64}","page":"Coupled Cluster","title":"PairingHamiltonian.unhash_key4","text":"unhash_key4(key::UInt64)::Tuple{Int, Int, Int, Int}\n\nFunction to decode i,j,a,b from a single UInt64.\n\n\n\n\n\n","category":"method"},{"location":"coupledcluster/#PairingHamiltonian.vecidx_to_idx-Tuple{Any, Any}","page":"Coupled Cluster","title":"PairingHamiltonian.vecidx_to_idx","text":"To get i and j for pp or hh from a vectorized index. Note that i must be less than j.\n\n\n\n\n\n","category":"method"},{"location":"hartreefock/#Hartree-Fock","page":"Hartree-Fock","title":"Hartree-Fock","text":"","category":"section"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"The Hartree-Fock (HF) method is based on the assumption that the many-body wave function can be approximated by a single Slater determinant.  The HF is nothing but a naive filling for the global pairing Hamiltonian, but it is a good starting point for more advanced methods such as MBPT, post-HF methods (CC, IMSRG, etc.). For this reason, some functions are not necessary for the HF method, but they are implemented for future use.","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Modules = [PairingHamiltonian]\nPages = [\"hartreefock.jl\"]","category":"page"},{"location":"hartreefock/#PairingHamiltonian.HF","page":"Hartree-Fock","title":"PairingHamiltonian.HF","text":"HF(Nocc, h1b, h2b, gval, to, debug_mode=0; itnum_max=100, tol=1e-9)\n\nMain function to compute the energies of the Hamiltonian by the Hartree-Fock method and perturbation theory.\n\nArguments\n\nNocc::Int64: Number of occupied orbitals.\nh1b::Matrix{Float64,2}: One-body Hamiltonian.\nh2b::Vector{Float64,1}: Two-body Hamiltonian flattened. This will be used only for the normal ordering.\ngval::Float64: Interaction strength.\nto::TimeOutput: TimeOutput object to measure the time.\n\nOptional arguments\n\ndebug_mode::Int64(0): If 1, print the energies at each iteration.\nitnum_max::Int64(100): Maximum number of iterations.\ntol::Float64(1e-9): Tolerance to stop the iteration.\n\n\n\n\n\n","category":"function"},{"location":"hartreefock/#PairingHamiltonian.define_holes_particles-Tuple{Any, Any}","page":"Hartree-Fock","title":"PairingHamiltonian.define_holes_particles","text":"define_holes_particles(F, Nocc)\n\nFunction to return the indices of the holes, which are below the Fermi level, and the particles, which are above the Fermi level.\n\n\n\n\n\n","category":"method"},{"location":"hartreefock/#PairingHamiltonian.eval_EHF-NTuple{4, Any}","page":"Hartree-Fock","title":"PairingHamiltonian.eval_EHF","text":"eval_EHF(h1b, gval, rho, Nocc)\n\nFunction to evaluate the energy of the Hamiltonian in the Hartree-Fock method.\n\nbeginalign\nE = E_1b + E_2b nonumber \nE_1b  = sum_i leq F sum_alphabeta C^T_i alpha C_i beta langle alpha  h  beta rangle =\nsum_alpha beta rho_alpha beta langle alpha  h  beta ranglenonumber  \nE_2b = frac12sum_alphabetagammadelta rho_alpha beta rho_gamma delta langle alpha gamma  v  beta delta rangle nonumber \nendalign\n\n\n\n\n\n","category":"method"},{"location":"hartreefock/#PairingHamiltonian.eval_Fock!-NTuple{5, Any}","page":"Hartree-Fock","title":"PairingHamiltonian.eval_Fock!","text":"eval_Fock!(F, rho, h1b, Nocc, gval)\n\nFunction to evaluate the Fock matrix destructively.\n\nF_alphabeta = langle alpha  h  beta rangle + sum_gamma delta rho_gamma delta langle alpha gamma  v  beta delta rangle\n\n\n\n\n\n","category":"method"},{"location":"hartreefock/#PairingHamiltonian.eval_rho!-Tuple{Any, Any, Any}","page":"Hartree-Fock","title":"PairingHamiltonian.eval_rho!","text":"eval_rho!(rho, U, Nocc)\n\nUpdate the density matrix with the coefficient matrix.\n\nrho_alphabeta = sum_i leq F C^T_i alpha C_i beta\n\n\n\n\n\n","category":"method"},{"location":"fullCI/#Full-CI","page":"Full CI","title":"Full-CI","text":"","category":"section"},{"location":"fullCI/","page":"Full CI","title":"Full CI","text":"Modules = [PairingHamiltonian]\nPages = [\"fullCI.jl\"]","category":"page"},{"location":"fullCI/#PairingHamiltonian.FCI","page":"Full CI","title":"PairingHamiltonian.FCI","text":"FCI(Hamil_mat, dim_basis, Norb, Nocc, gval, save_Exact_wf, to, debug_mode=0; return_only_E0=true)\n\nMain function to compute the ground state energy with the full CI method. If the system size is small, the Hamiltonian matrix is explicitly constructed and diagonalized using the eigen function in LinearAlgebra.jl. If the system size is large, the Hamiltonian matrix is sparsely represented and the Lanczos method is used to compute the smallest eigenvalue.\n\nArguments\n\nHamil_mat: Hamiltonian matrix, either a Matrix{Float64} or a Dict{UInt64, Float64}.\ndim_basis: Dimension of the basis, i.e. number of configurations\nNorb: Number of orbitals\nNocc: Number of occupied orbitals\ngval: Interaction strength\nsave_Exact_wf: If true, save the exact wave function to a HDF5 file\nto: TimerOutput object\ndebug_mode: the level of debug information\nreturn_only_E0: If true, return only the ground state energy, otherwise return the eigenvalues and eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"fullCI/#PairingHamiltonian.lanczos-NTuple{4, Any}","page":"Full CI","title":"PairingHamiltonian.lanczos","text":"lanczos(Hamil_mat, dim, save_Exact_wf, to; itnum=300, tol=1e-9, debug_mode=0)\n\nFunction to compute the lowest eigenvalue of the Hamiltonian using the Lanczos method.\n\nConstructing a Krylov subspace mathcalK_m(Hv) = mathrmspanv Hv H^2v cdots H^m-1v, and the tridiagonal matrix T_m = V_m^T H V_m where V_m = v_1 v_2 cdots v_m and v_m+1 = H v_m - alpha_m v_m - beta_m v_m-1, the Lanczos method iteratively constructs the matrix T_m and diagonalizes it to obtain the smallest eigenvalue of H.\n\nArguments\n\nHamil_mat: Hamiltonian matrix, either a Matrix{Float64} or a Dict{UInt64, Float64}.\ndim: Dimension of the basis, i.e. number of configurations\nsave_Exact_wf: If true, save the exact wave function to a HDF5 file\nto: TimerOutput object\n\nOptional arguments\n\nitnum: Number of Lanczos iterations\ntol: Tolerance for convergence\ndebug_mode: the level of debug information\n\n\n\n\n\n","category":"method"},{"location":"fullCI/#PairingHamiltonian.make_gs_wf-NTuple{4, Any}","page":"Full CI","title":"PairingHamiltonian.make_gs_wf","text":"make_gs_wf(vks, Tmat, Lan_itnum, num_ev)\n\nFunction to construct the ground state wave function from the Lanczos vectors.\n\npsi_rm GSrangle = sum_k=1^D c_k v_krangle\n\nwhere D is the number of Lanczos iterations, and c_k is the eigenvector of the tridiagonal matrix T corresponding to the smallest eigenvalue.\n\nArguments\n\nvks: Lanczos vectors\nTmat: Tridiagonal matrix\nLan_itnum: Number of Lanczos iterations\nnum_ev: Number of the eigenvector to be used\n\n\n\n\n\n","category":"method"},{"location":"fullCI/#PairingHamiltonian.operate_H_on_vec!-Tuple{Any, Dict{UInt64, Float64}, Any}","page":"Full CI","title":"PairingHamiltonian.operate_H_on_vec!","text":"operate_H_on_vec!(w, Hamil_mat::Dict{UInt64, Float64}, v)\n\nSparse version of the function to compute the matrix-vector product of the Hamiltonian matrix in the form of Dict{UInt64, Float64} and a vector.\n\n\n\n\n\n","category":"method"},{"location":"fullCI/#PairingHamiltonian.operate_H_on_vec!-Tuple{Any, Matrix{Float64}, Any}","page":"Full CI","title":"PairingHamiltonian.operate_H_on_vec!","text":"operate_H_on_vec!(w, Hamil_mat::Array{Float64, 2}, v)\n\nFunction to compute the matrix-vector product of the Hamiltonian matrix and a vector.\n\n\n\n\n\n","category":"method"},{"location":"fullCI/#PairingHamiltonian.reOrthogonalize!-Tuple{Any, Any, Any}","page":"Full CI","title":"PairingHamiltonian.reOrthogonalize!","text":"reOrthogonalize!(w, vks, i)\n\nRe-orthogonalize the vector w with respect to the previous vectors:\n\nw = w - sum_j=1^i langle w v_j rangle v_j\n\n\n\n\n\n","category":"method"},{"location":"fullCI/#PairingHamiltonian.write_Exact_wf_hdf5-NTuple{4, Any}","page":"Full CI","title":"PairingHamiltonian.write_Exact_wf_hdf5","text":"write_Exact_wf_hdf5(evec, Norb, Nocc, gval)\n\nFunction to save the exact wave function to a HDF5 file.\n\nArguments\n\nevec: Exact wave function\nNorb: Number of orbitals\nNocc: Number of occupied orbitals\ngval: Interaction strength\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributing-to-PairingHamiltonian.jl","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"Thank you for considering contributing to this package.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"Feedbacks and contributions to this package are very welcome. These can be:","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"bug report\nsubmitting a new function or a patch to the bug\ndocumentation issue\nfeature request\netc.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"For these contributions, it would be nice to let you know a basic policy (the workflow of code development and LICENSE, shown below) in this package. Note that the package has been developed by a single author (@SotaYoshida) so far, and thereby the followings are just the author's policy. Comments on the development policy itself are also welcome.","category":"page"},{"location":"contributing/#Workfklow-of-code-development","page":"Contributing to PairingHamiltonian","title":"Workfklow of code development","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"We use the GitHub to host the package, to track issues/pull requests.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"The document is built using Documenter.jl, which is a package for building documentation from docstrings and markdown files. It is automized to build and deploy the document using GitHub Actions.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"A typical workfklow of code development is the following:","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"clone or folk the repository and modify the code and/or document locally\npropose modifications through a pull request (PR) to develop branch\nif the PR passes the automated tests, it will be merged \nAt some point, we tag and release, which is done automatically by instructing the JuliaRegistrator bot to do so.","category":"page"},{"location":"contributing/#Automated-tests-on-GitHub-Actions","page":"Contributing to PairingHamiltonian","title":"Automated tests on GitHub Actions","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"We use GitHub Actions to run the test codes and to build/deploy the document. When some changes are submitted through a pull request, the test codes are run to check that the changes are not destructive.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"The test jobs are specified in yml files like .github/workflows/CI.yml and one can find the test code in test/ of the repository.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"note: Note\nIf you submit a major change to the code, please consider to update the test codes matching to your modifications.","category":"page"},{"location":"contributing/#Reporting-bugs-by-opening-a-new-issue","page":"Contributing to PairingHamiltonian","title":"Reporting bugs by opening a new issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"Thank you so much for considering to report bugs! When you report a bug in the code, please open an new issue at the repository. Please make sure to include any information necessary for us to reproduce the errors. Thanks!","category":"page"},{"location":"contributing/#Propose-modifications-through-Pull-Requests-(PRs)","page":"Contributing to PairingHamiltonian","title":"Propose modifications through Pull Requests (PRs)","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"You can propose modifications you made on the package through pull requests.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"As stated above, please consider to make test codes matching to your modifications.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"Please make sure to submit your PR to develop branch. The 'main' branch will be protected by 'github branch protection'.","category":"page"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"As this package is currently being developed by a single author, branching rules such as git-flow and GitHub Flow have not been adopted. When we got contributors, the branch-rule will be set upon discussions.","category":"page"},{"location":"contributing/#LICENSE","page":"Contributing to PairingHamiltonian","title":"LICENSE","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PairingHamiltonian","title":"Contributing to PairingHamiltonian","text":"Any contribution from you will be under the MIT License, as well as the package itself. Feel free to contact to @SotaYoshida if that's a concern.","category":"page"},{"location":"hamiltonian/#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Functions for constructing paring Hamiltonian and some utilities for handling it.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"H_mathrmpair = sum_i=1^N epsilon_i a_i^dagger a_i - fracg4 sum_ij a_i^dagger a^dagger_bari a_barj a_j","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"One can use the following methods to solve the pairing Hamiltonian with the package:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"\"Full-CI\": Full-CI/Exact diagonalization\n\"Full-CI(2-fold)\": Full-CI/Exact diagonalization assuming that particles are paired\n\"HF\": Hartree-Fock (nothing but naive filling due to the pairing Hamiltonian)    Under this method, MBPT calculation with the HF reference state are carried out.\n\"BCS\": Bardeen-Cooper-Schrieffer\n\"CCD\": Coupled Cluster, especially CCD\n\"IMSRG(2)\": In-Medium Similarity Renormalization Group, especially IM-SRG(2)","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Modules = [PairingHamiltonian]\nPages = [\"hamiltonian.jl\"]","category":"page"},{"location":"hamiltonian/#PairingHamiltonian.Pairing_Hamiltonian-Tuple{}","page":"Hamiltonian","title":"PairingHamiltonian.Pairing_Hamiltonian","text":"Pairing_Hamiltonian(to; Norb_in::Int=8, Nocc_in::Int=4, gval::Float64=0.33, delta_eps::Float64=1.0,\n                    debug_mode::Int=0, solver::String=\"FCI(2-fold)\", save_Exact_wf::Bool=false)\n\nMain function to evaluate the ground state energy of the pairing Hamiltonian.\n\nOptional arguments with default values\n\nNorb_in::Int=8: number of orbitals\nNocc_in::Int=4: number of occupied states\ngval::Float64=0.33: pairing strength\ndelta_eps::Float64=1.0: energy difference between orbitals\ndebug_mode::Int=0: specify the debug mode\nsolver::String(\"FCI(2-fold)\"): method to solve the Hamiltonian. This can be one of \"Full-CI\", \"Full-CI(2-fold)\", \"HF\", \"BCS\", \"CCD\", \"IMSRG(2)\". If \"HF\" is chosen, PT2/PT3 energies are also calculated.\nsave_Exact_wf::Bool(false): save the full-CI wave functions as HDF5 files, which can be used for e.g. analysis of the wave functions and constructing surrogate models like eigenvector continuation.\nto: either nothing or TimerOutput object defined in a user script.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.bitstr2int-Tuple{String}","page":"Hamiltonian","title":"PairingHamiltonian.bitstr2int","text":"bitstr2int(bitstr::String)::Int\n\nConvert a bitstring representation (e.g., \"00110\") to an integer (e.g., 6).\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.check_connectivity-NTuple{5, Int64}","page":"Hamiltonian","title":"PairingHamiltonian.check_connectivity","text":"check_connectivity(psi_l::Int, psi_r::Int, p::Int, q::Int, Nq::Int)::Bool\n\nCheck if the configurations (in bit representation) are connected by the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.eval_Hamil-Tuple{String, Vector{Int64}, Vector{Float64}, Float64, Int64, Bool}","page":"Hamiltonian","title":"PairingHamiltonian.eval_Hamil","text":"eval_Hamil(method::String, basis::Vector{Int}, eps::Vector{Float64}, g::Float64, Nq::Int, degenerate::Bool; debug_mode::Int=0, sparce_rep::Bool=false)::Tuple{Matrix{Float64}, Matrix{Float64}, Union{Matrix{Float64}, Dict{UInt64, Float64}}}\n\nFunction to evaluate the Hamiltonian matrix elements. Once the number of orbitals and the number of occupied states are given, one can prepare the Hamiltonian matrix elements in the full matrix representation or sparse representation. For larger systems, sparse representation using Dict{UInt64, Float64} is used instead of storing the full matrix. The keys of the dictionary correspond to the integer representation of many-body configurations.\n\nNote that \"1\" and '1' are different in Julia. The former is a string, while the latter is a character.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.hash_key2-Tuple{Any, Any}","page":"Hamiltonian","title":"PairingHamiltonian.hash_key2","text":"hash_key2(i::Int, j::Int)::UInt64\n\nHash the pair of indices to a key.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.int2bitstr-Tuple{Any, Any}","page":"Hamiltonian","title":"PairingHamiltonian.int2bitstr","text":"int2bitstr(x::Int, N::Int)::String\n\nConvert an integer to a bitstring of length N. Similar thing can be done with string function in Julia, but this is more proper way for \"0\" padding. \n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.prepare_basis-Tuple{Any, Any}","page":"Hamiltonian","title":"PairingHamiltonian.prepare_basis","text":"Create a list of configurations where n out of N are occupied.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#PairingHamiltonian.unhash_key2-Tuple{UInt64}","page":"Hamiltonian","title":"PairingHamiltonian.unhash_key2","text":"unhash_key2(key::UInt64)::Tuple{Int, Int}\n\nUnhash the key to the pair of indices.\n\n\n\n\n\n","category":"method"},{"location":"eigenvectorcontinuation/#Eigenvector-Continuation","page":"Eigenvector Continuation","title":"Eigenvector Continuation","text":"","category":"section"},{"location":"eigenvectorcontinuation/","page":"Eigenvector Continuation","title":"Eigenvector Continuation","text":"Modules = [PairingHamiltonian]\nPages = [\"eigenvector_continuation.jl\"]","category":"page"},{"location":"eigenvectorcontinuation/#PairingHamiltonian.EC_from_FCI-Tuple{Any, Any}","page":"Eigenvector Continuation","title":"PairingHamiltonian.EC_from_FCI","text":"EC_from_FCI(Norb_in, Nocc_in; target_dirs=\"eigenstates_fullCI\", gvals_specified::Vector{Float64} = Vector{Float64}[], gvals_target=collect(-2.0:0.1:2.0), degenerate = true, delta_eps::Float64=1.0)\n\nMain function to compute the energy curve by EC method from the FCI wavefunctions. Assuming that the FCI wavefunctions are already evaluated and saved in a directory.\n\nArguments\n\nNorb_in::Int64: Number of orbitals. \nNocc_in::Int64: Number of electrons.\ntarget_dirs::String: Directory name where the FCI wavefunctions are saved.\ngvals_specified::Vector{Float64}: List of gvals to be used as snapshots. If empty, all the snapshots extracted via glob will be used.\n\n\n\n\n\n\n","category":"method"},{"location":"eigenvectorcontinuation/#PairingHamiltonian.read_snapshot-Tuple{Any}","page":"Eigenvector Continuation","title":"PairingHamiltonian.read_snapshot","text":"read_snapshot(fn::String)\n\nRead the snapshot from the file fn and return the data as a tuple of Norb, Nocc, gval, and evec. Note that the snapshot is assumed to be written out by write_Exact_wf_hdf5 function in src/fullCI.jl.\n\n\n\n\n\n","category":"method"},{"location":"eigenvectorcontinuation/#PairingHamiltonian.solve_gen_eig-Tuple{Any, Any}","page":"Eigenvector Continuation","title":"PairingHamiltonian.solve_gen_eig","text":"solve_gen_eig(tildeH, tildeN)\n\nSolve the generalized eigenvalue problem tildeH v = E N v and return the minimum eigenvalue E. Now it is implemented by the eigen function in Julia, but it can be ill-conditioned for large systems, so it is better to use e.g. Cholesky decomposition and iterative solver like Arpack or KrylovKit for more general cases.\n\n\n\n\n\n","category":"method"},{"location":"#PairingHamiltonian.jl","page":"Home","title":"PairingHamiltonian.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package to solve pairing Hamiltonian with a bunch of many-body methods used in nuclear physics.","category":"page"},{"location":"#Why-I-Created-PairingHamiltonian.jl","page":"Home","title":"Why I Created PairingHamiltonian.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I started to use Julia in 2018, and I was fascinated by the performance, the simplicity of the language, and  the philosophy of the Julia language, such as the following: Why We Created Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Upon the request to give a lecture in a summer school in Japan, I decided to develop a Julia package and open it to the public. The pairing Hamiltonian is a simple model, but it is very important in nuclear physics, condensed matter physics, and provides a good starting point to learn methods to solve many-body problems, quantum computing, and so on.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nuclear many-body methods today are very diverse and rich. This may originate from a long history of nuclear physics and rich phenomena in nuclei, which have led to the development of many methods to describe the nuclear structure and reactions from different perspectives. This is a good thing and very fascinating. I really love the diversity of the methods and the rich phenomena in nuclei. However, it may be difficult for beginners like Bachelor students or first-year graduate students to understand the whole picture of the nuclear many-body methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I was one such student, to be honest. I was struggling to understand the many-body methods in nuclear physics in the first year of the graduate school. (I am still struggling, but I am enjoying it now.) This package is designed to help a student (like old me) to dive into the many-body methods in nuclear physics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I would be very happy if this package provides a good starting point for students to learn the many-body methods in nuclear physics, and to develop something new.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package itself is not covering quantum computing methods, but this can be used as a reference to play with the quantum computing methods. Regarding the quantum computing methods, I have developed and opened some materials to solve the pairing Hamiltonian with quantum algorithms, VQE, Hadamard test, QPE, Quantum Lanczos with either PennyLane/Qiskit/Pytket. Those materials will be available through the following repository: Lecture_SummerSchool2025 This is for the summer school in Japan, so the materials are written in Japanese, but I am planning to make an English version in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I have been developing another Julia package, NuclearToolkit.jl covering chiral EFT potentials, and methods like ones in this package. After getting used to methods provided in this package, you can use the NuclearToolkit.jl to solve more realistic nuclear physics problems.","category":"page"},{"location":"#Installation-and-example","page":"Home","title":"Installation and example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, prepare Julia environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Second, add the package in Pkg mode of the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]add PairingHamiltonian","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, you can use the package as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PairingHamiltonian","category":"page"},{"location":"","page":"Home","title":"Home","text":"That's it. You are ready to use the package.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PairingHamiltonian.jl is a Julia package to solve the pairing Hamiltonian with a bunch of many-body machinery. The package is covering the following methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Full-CI/Exact diagonalization \nHartree-Fock\nBardeen-Cooper-Schrieffer (BCS)\nMany-Body Perturbation Theory\nCoupled Cluster\nIn-Medium Similarity Renormalization Group\nEigenvector Continuation","category":"page"},{"location":"","page":"Home","title":"Home","text":"To author's knowledge, this is the first open-source software that provides all these methods in a single package. One can use the package to get used to the many-body methods, and to build a new method by combining or modifying the existing methods.","category":"page"},{"location":"#Issues/Pull-requests","page":"Home","title":"Issues/Pull requests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is designed to be an open-source software, and the author is welcoming any contributions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Especially, the author would like to get feedback from students who are using this package to learn the many-body methods in nuclear physics. Of course, contributions from other fields are highly welcome. Making issues and pull requests are welcome. More details are in the Contributing to PairingHamiltonian.jl.","category":"page"},{"location":"mbpt/#Many-Body-Perturbation-Theory","page":"MBPT","title":"Many-Body Perturbation Theory","text":"","category":"section"},{"location":"mbpt/","page":"MBPT","title":"MBPT","text":"One can use the Many-Body Perturbation Theory (MBPT) to calculate the ground state energy of a system. In the package, PT2 and PT3 are implemented, and can be used to calculate the ground state energy of a system. Users do not have to specify \"MBPT2\" or \"MBPT3\" in the input file, as the package will automatically use the methods when the Hartree-Fock calculation is called.","category":"page"},{"location":"mbpt/","page":"MBPT","title":"MBPT","text":"Modules = [PairingHamiltonian]\nPages = [\"mbpt.jl\"]","category":"page"},{"location":"mbpt/#PairingHamiltonian.PT2-Tuple{Any, Any, Any}","page":"MBPT","title":"PairingHamiltonian.PT2","text":"PT2(F, Nocc, gval)\n\nFunction to calculate the second order perturbation theory contribution to the energy.\n\nfrac14 sum^leq epsilon_F_ijsum^geq epsilon_F_pq frac langle ij  V  pq rangle langle pq  V  ij rangle\nepsilon_i + epsilon_j - epsilon_p - epsilon_q \n\nFor the pairing Hamiltonian, j should be the pair of i and p should be the pair of q, and the numerator will be g^2.\n\n\n\n\n\n","category":"method"},{"location":"mbpt/#PairingHamiltonian.PT3-Tuple{Any, Any, Any}","page":"MBPT","title":"PairingHamiltonian.PT3","text":"PT3(F, Nocc, gval)\n\nFunction to calculate the third order perturbation theory contribution to the energy.\n\nbeginalign\nDelta E^(3)_pp \n= frac18 sum_ij leq F sum_abcd  F fracbraij hatV ketab braab hatV ketcd bracd hatV ketij\nepsilon^ab_ij epsilon^cd_ij  \nDelta E^(3)_hh \n= frac18 sum_ijkl leq F sum_ab  F fracbraij hatV ketab brakl hatV ketkl brakl hatV ketij\n    epsilon^ab_ij epsilon^ab_kl \nDelta E^(3)_ph \n= - sum_ijk leq F sum_abc  F fracbraij hatV ketab brakb hatV ketic braac hatV ketkj\n    epsilon^ab_ij epsilon^ac_kj\nendalign\n\nFor the global pairing Hamiltonian, the PT3 is much simpler than the general case as in the PT2, since the numerator will be proportional to g^3 and the ph term is zero.\n\n\n\n\n\n","category":"method"}]
}
